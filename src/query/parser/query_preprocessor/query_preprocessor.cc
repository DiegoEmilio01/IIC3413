#include "query_preprocessor.h"

#include <memory>
#include <stdexcept>
#include <variant>

#include "exceptions/exceptions.h"
#include "query/parser/grammar/autogenerated/IIC3413DBParser.h"
#include "query/parser/logical_plan/logical_plans.h"
#include "query/parser/logical_plan/expr/expr_plans.h"
#include "relational_model/catalog.h"
#include "relational_model/system.h"


std::any QueryPreprocessor::visitRoot(IIC3413DBParser::RootContext* ctx) {
    visitChildren(ctx);
    return 0;
}


std::any QueryPreprocessor::visitQuery(IIC3413DBParser::QueryContext* ctx) {
    visitChildren(ctx);
    return 0;
}


std::any QueryPreprocessor::visitCreateQuery(IIC3413DBParser::CreateQueryContext* ctx) {
    const auto table_name = Catalog::normalize(ctx->identifier()->getText());

    if (catalog.table_exists(table_name)) {
        throw QueryException("Table " + table_name + " already exists");
    }

    std::vector<std::string> column_names;
    std::vector<DataType>    column_types;
    for (const auto& schema : ctx->schema()) {
        const auto column_name = Catalog::normalize(schema->identifier()->getText());
        column_names.emplace_back(column_name);

        const auto column_datatype = schema->datatype();
        if (column_datatype->STR() != nullptr) {
            column_types.emplace_back(DataType::STR);
        } else if (column_datatype->INT() != nullptr) {
            column_types.emplace_back(DataType::INT);
        } else {
            throw NotImplementedException("Unhandled DataType:" + column_datatype->getText());
        }
    }

    Schema schema(std::move(column_names), std::move(column_types));
    throw NotImplementedException("TableCreationPlan");
    return 0;
}


std::any QueryPreprocessor::visitInsertQuery(IIC3413DBParser::InsertQueryContext* ctx) {
    const auto table_name = Catalog::normalize(ctx->identifier()->getText());

    if (!catalog.table_exists(table_name)) {
        throw QueryException("Table " + table_name + " does not exist");
    }

    const auto& table_info = catalog.get_table_info(table_name);
    const auto& schema     = table_info.schema;
    const auto& datatypes  = schema->datatypes;

    if (datatypes.size() != ctx->constant().size()) {
        throw QueryException("Table " + table_name + " has " + std::to_string(schema->column_names.size())
                             + " columns, but " + std::to_string(ctx->constant().size()) + " values were provided");
    }

    std::vector<Constant> values;
    for (size_t i = 0; i < datatypes.size(); i++) {
        const auto result = get_constant<Constant>(ctx->constant(i));

        switch (datatypes[i]) {
        case DataType::INT: {
            if (!std::holds_alternative<int64_t>(result))
                throw QueryException("Value for " + table_name + "." + schema->column_names[i] + " must be INT");
            break;
        }
        case DataType::STR: {
            if (!std::holds_alternative<std::string>(result))
                throw QueryException("Values for " + table_name + "." + schema->column_names[i] + " must be STRING");
            break;
        }
        default: {
            throw NotImplementedException("Unhandled DataType: " + std::to_string(static_cast<int>(datatypes[i])));
        }
        }

        values.emplace_back(result);
    }

    throw NotImplementedException("TableInsertion");
    return 0;
}


std::any QueryPreprocessor::visitSelectQuery(IIC3413DBParser::SelectQueryContext* ctx) {
    if (ctx->limitStatement()) {
        try {
            limit = std::stoll(ctx->limitStatement()->INTEGER()->getText());
        }
        catch (std::out_of_range& e) {
            throw QueryException("Integer " + ctx->limitStatement()->INTEGER()->getText()
                + " is out of range");
        }

        if (limit <= 0) {
            throw QueryException("Invalid LIMIT " + std::to_string(limit));
        }
    }

    visit(ctx->fromStatement());
    if (ctx->whereStatement() != nullptr) {
        visit(ctx->whereStatement());
    }
    visit(ctx->selectStatement());

    return 0;
}


std::any QueryPreprocessor::visitSelectStatement(IIC3413DBParser::SelectStatementContext* ctx) {
    bool distinct = ctx->DISTINCT() != nullptr;

    std::vector<Column> projection;

    if (ctx->ASTERISK() != nullptr) {
        // Project all columns from selected tables
        for (auto&& [alias, table_name] : from_tables) {
            const auto& table_info   = catalog.get_table_info(table_name);
            const auto& schema       = table_info.schema;
            const auto& column_names = schema->column_names;
            for (const auto& column_name : column_names) {
                projection.emplace_back(
                    alias,
                    table_name,
                    column_name,
                    catalog.get_datatype(table_name, column_name));
            }
        }
    } else {
        // Project specified columns
        for (const auto& column_ctx : ctx->columnList()->column()) {
            auto column = get_column(column_ctx);
            projection.emplace_back(column);
        }
    }

    current_logical_plan = std::make_unique<ProjectionPlan>(
        std::move(current_logical_plan),
        distinct,
        limit,
        std::move(projection));

    return 0;
}


std::any QueryPreprocessor::visitFromStatement(IIC3413DBParser::FromStatementContext* ctx) {
    visitChildren(ctx);
    return 0;
}


std::any QueryPreprocessor::visitTableList(IIC3413DBParser::TableListContext* ctx) {
    for (auto& table_ctx : ctx->table()) {
        std::string table_name = Catalog::normalize(table_ctx->identifier(0)->getText());
        if (!catalog.table_exists(table_name)) {
            throw QueryException("Table " + table_name + " does not exist");
        }

        std::string alias;
        if (table_ctx->AS() != nullptr) {
            alias = Catalog::normalize(table_ctx->identifier(1)->getText());
        } else {
            alias = table_name;
        }

        if (!from_tables.insert({ alias, table_name}).second) {
            throw QueryException("Table " + alias + " should only appear once in the FROM clause");
        }
    }

    if (from_tables.size() > 1) {
        std::vector<std::unique_ptr<LogicalPlan>> relations;
        for (auto&& [alias, table_name] : from_tables) {
            relations.emplace_back(std::make_unique<RelationPlan>(alias, table_name));
        }
        current_logical_plan = std::make_unique<CartesianProductPlan>(std::move(relations));
    } else {
        current_logical_plan = std::make_unique<RelationPlan>(
            from_tables.begin()->first,
            from_tables.begin()->second
        );
    }

    return 0;
}


std::any QueryPreprocessor::visitWhereStatement(IIC3413DBParser::WhereStatementContext* ctx) {
    visitChildren(ctx);
    return 0;
}


std::any QueryPreprocessor::visitAndExpr(IIC3413DBParser::AndExprContext* ctx) {
    std::vector<std::unique_ptr<ExprPlan>> expressions;

    for (const auto& simpleExpr : ctx->simpleExpr()) {
        simpleExpr->accept(this);
        expressions.emplace_back(std::move(current_expr));
    }

    current_logical_plan = std::make_unique<SelectionPlan>(
        std::move(current_logical_plan),
        std::move(expressions)
    );

    return 0;
}


std::any QueryPreprocessor::visitSimpleExpr(IIC3413DBParser::SimpleExprContext* ctx) {
    visitChildren(ctx);
    return 0;
}


std::any QueryPreprocessor::visitComparisonExpr(IIC3413DBParser::ComparisonExprContext* ctx) {
    ctx->columnOrConstant(0)->accept(this);
    auto lhs = std::move(current_expr);

    ctx->columnOrConstant(1)->accept(this);
    auto rhs = std::move(current_expr);

    auto lhs_type = lhs->get_datatype();
    auto rhs_type = rhs->get_datatype();

    if (lhs_type != rhs_type) {
        throw QueryException("Cannot compare different DataTypes: " + ctx->getText());
    }

    auto op = ctx->op->getText();
    if (op == "==") {
        current_expr = std::make_unique<ExprPlanEquals>(std::move(lhs), std::move(rhs));
    } else if (op == "!=") {
        current_expr = std::make_unique<ExprPlanNotEquals>(std::move(lhs), std::move(rhs));
    } else if (op == "<") {
        current_expr = std::make_unique<ExprPlanLess>(std::move(lhs), std::move(rhs));
    } else if (op == "<=") {
        current_expr = std::make_unique<ExprPlanLessOrEquals>(std::move(lhs), std::move(rhs));
    } else if (op == ">=") {
        current_expr = std::make_unique<ExprPlanLessOrEquals>(std::move(rhs), std::move(lhs));
    } else if (op == ">") {
        current_expr = std::make_unique<ExprPlanLess>(std::move(rhs), std::move(lhs));
    }
    else {
        throw std::invalid_argument(op + " not recognized as a valid ComparisonExpr operator");
    }
    return 0;
}


std::any QueryPreprocessor::visitLikeExpr(IIC3413DBParser::LikeExprContext* ctx) {
    auto col_expr = std::make_unique<ExprPlanColumn>(
        get_column(ctx->column())
    );

    if (col_expr->column.datatype != DataType::STR) {
        throw QueryException("LIKE can only be applied to strings");
    }

    auto pattern = ctx->STRING()->getText();
    pattern = pattern.substr(1, pattern.size() - 2); // remove double quotes

    current_expr = std::make_unique<ExprPlanLike>(
        std::move(col_expr),
        std::move(pattern)
    );
    return 0;
}


Value get_value(IIC3413DBParser::ConstantContext* ctx) {
    if (ctx->STRING() != nullptr) {
        auto string = ctx->STRING()->getText();
        string      = string.substr(1, string.size() - 2);
        if (string.size() > Record::MAX_STRLEN) {
            throw QueryException("String \"" + string + "\" is too long (" + std::to_string(string.size()) + " > "
                                 + std::to_string(Record::MAX_STRLEN) + ")");
        }
        return Value(string);
    } else if (ctx->INTEGER() != nullptr) {
        try {
            return Value((int64_t)std::stoll(ctx->INTEGER()->getText()));
        }
        catch (std::out_of_range& e) {
            throw QueryException("Integer " + ctx->INTEGER()->getText() + " is out of range");
        }
    } else {
        throw NotImplementedException("Unhandled Constant: " + ctx->getText());
    }
}


std::any QueryPreprocessor::visitColumnOrConstant(IIC3413DBParser::ColumnOrConstantContext* ctx) {
    if (ctx->column()) {
        current_expr = std::make_unique<ExprPlanColumn>(
            get_column(ctx->column())
        );

    } else if (ctx->constant()) {
        if (ctx->constant()->INTEGER()) {
            int64_t int_value;
            try {
                int_value = std::stoll(ctx->constant()->INTEGER()->getText());
            }
            catch (std::out_of_range& e) {
                throw QueryException("Integer " + ctx->constant()->INTEGER()->getText() + " is out of range");
            }
            current_expr = std::make_unique<ExprPlanTerm>(
                Value(int_value)
            );
        } else {
            assert(ctx->constant()->STRING() != nullptr);

            auto str_value = ctx->constant()->STRING()->getText();
            str_value      = str_value.substr(1, str_value.size() - 2);
            if (str_value.size() > Record::MAX_STRLEN) {
                throw QueryException("String \"" + str_value + "\" is too long (" + std::to_string(str_value.size()) + " > "
                                    + std::to_string(Record::MAX_STRLEN) + ")");
            }

            current_expr = std::make_unique<ExprPlanTerm>(
                Value(str_value)
            );
        }
    }
    return 0;
}


template<typename ReturnType>
ReturnType QueryPreprocessor::get_constant(IIC3413DBParser::ConstantContext* ctx) const {
    if (ctx->STRING() != nullptr) {
        auto string = ctx->STRING()->getText();
        string      = string.substr(1, string.size() - 2);
        if (string.size() > Record::MAX_STRLEN) {
            throw QueryException("String \"" + string + "\" is too long (" + std::to_string(string.size()) + " > "
                                 + std::to_string(Record::MAX_STRLEN) + ")");
        }
        return string;
    } else if (ctx->INTEGER() != nullptr) {
        try {
            return std::stoll(ctx->INTEGER()->getText());
        }
        catch (std::out_of_range& e) {
            throw QueryException("Integer " + ctx->INTEGER()->getText() + " is out of range");
        }
    } else {
        throw NotImplementedException("Unhandled Constant: " + ctx->getText());
    }
}


Column QueryPreprocessor::get_column(IIC3413DBParser::ColumnContext* ctx) const {
    if (ctx->identifier().size() == 2) {
        auto alias  = Catalog::normalize(ctx->identifier(0)->getText());
        auto column = Catalog::normalize(ctx->identifier(1)->getText());

        auto it = from_tables.find(alias);
        if (it == from_tables.end()) {
            throw QueryException("Table " + alias + ", not present in FROM");
        }

        auto table = it->second;

        return Column(alias, table, column, catalog.get_datatype(table, column));
    } else {
        // Only column name
        auto column = Catalog::normalize(ctx->identifier(0)->getText());

        // try to infer the table from catalog from tables named in FROM
        const std::string* found_table = nullptr;
        for (auto&& [alias, table_name] : from_tables) {
            if (alias != table_name) {
                continue; // skip from tables with aliases
            }

            auto& schema = catalog.get_table_info(table_name).schema;
            for (size_t i = 0; i < schema->column_names.size(); i++) {
                if (schema->column_names[i] == column) {
                    if (found_table == nullptr) {
                        found_table = &table_name;
                    } else {
                        throw QueryException("Ambiguous column `" + column + "`, present in tables `"
                            + *found_table + "` and `" + table_name + "`");
                    }
                }
            }
        }
        if (found_table == nullptr) {
            throw QueryException("Could not infer the table where column `" + column + "` belongs");
        }

        return Column(*found_table, *found_table, column, catalog.get_datatype(*found_table, column));
    }
}
