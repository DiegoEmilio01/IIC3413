#pragma once

#include "antlr4-runtime.h"

#include <memory>
#include <string>

#include "antlr_error_listener.h"
#include "query/parser/grammar/autogenerated/IIC3413DBLexer.h"
#include "query/parser/grammar/autogenerated/IIC3413DBParser.h"
#include "query/parser/query_preprocessor/query_preprocessor.h"
#include "query/parser/query_rewriter/build_joins.h"
#include "query/parser/query_rewriter/push_selection.h"


namespace Parser {

static inline std::unique_ptr<LogicalPlan> parse(const std::string& query, bool explain) {
    antlr4::ANTLRInputStream  input(query);
    IIC3413DBLexer            lexer(&input);
    antlr4::CommonTokenStream tokens(&lexer);
    IIC3413DBParser           parser(&tokens);

    parser.getInterpreter<antlr4::atn::ParserATNSimulator>()->setPredictionMode(
        antlr4::atn::PredictionMode::SLL
    );

    AntlrErrorListener error_listener;
    parser.removeErrorListeners();
    parser.addErrorListener(&error_listener);

    auto tree = parser.root();

    QueryPreprocessor query_preprocessor;
    auto logical_plan = query_preprocessor.do_visit(tree);

    if (explain) {
        std::cout << "Initial Logical Plan:\n";
        std::cout << *logical_plan << std::endl;
    }

    QueryRewriter::BuildJoins build_joins;
    logical_plan->accept_visitor(build_joins);
    logical_plan = std::move(build_joins.current_plan);

    if (explain) {
        std::cout << "Logical Plan after Build Joins:\n";
        std::cout << *logical_plan << std::endl;
    }

    QueryRewriter::PushSelection push_selection;
    logical_plan->accept_visitor(push_selection);
    logical_plan = std::move(push_selection.current_plan);

    if (explain) {
        std::cout << "Logical Plan after Push Selection:\n";
        std::cout << *logical_plan << std::endl;
    }

    return logical_plan;
}

} // namespace Parser
